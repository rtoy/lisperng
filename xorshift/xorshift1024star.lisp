(declaim (type (integer 0 31) *p*)
	 (type (simple-array (unsigned-byte 32) (32)) *s*))
(defvar *p* 0)
(defvar *s* (make-array 32 :element-type '(unsigned-byte 32)))

(defun init-xor-shift-1024* (init)
  (setf *p* 0)
  (dotimes (k 32)
    (setf (aref *s* k) (aref init k))))

;;(declaim (ext:start-block xor-shift-1024*/32 xor-shift-1024*))
(defun xor-shift-1024*/32 (state-index state-array)
  (declare (type (integer 0 31) state-index)
	   (type (simple-array (unsigned-byte 32) (32)) state-array)
	   (optimize (speed 3) (safety 0)))
  (let ((s0l (aref state-array state-index))
	(s0h (aref state-array (+ state-index 1))))
    (setf state-index (logand 31 (+ state-index 2)))
    (let ((s1l (aref state-array state-index))
	  (s1h (aref state-array (+ state-index 1))))
      ;; s1 ^= s1 << 31
      (multiple-value-bind (t1 t0)
	  (64bit-ashl s1h s1l 31)
	(setf s1h (logxor s1h t1)
	      s1l (logxor s1l t0)))
      ;; new = s1 ^ s0
      (let ((new-l (logxor s1l s0l))
	    (new-h (logxor s1h s0h)))
	(declare (type (unsigned-byte 32) new-l new-h))
	;; new ^= s1 >> 11
	(multiple-value-bind (t1 t0)
	    (64bit-ashr s1h s1l 11)
	  (setf new-h (logxor new-h t1)
		new-l (logxor new-l t0)))
	;; new ^= s0 >> 30
	(multiple-value-bind (t1 t0)
	    (64bit-ashr s0h s0l 30)
	  (setf new-h (logxor new-h t1)
		new-l (logxor new-l t0)))
	;; Save new state
	(setf (aref state-array state-index) new-l
	      (aref state-array (+ state-index 1)) new-h)
	;; new * 1181783497276652981
	(let ((mul-l (ldb (byte 32 0) 1181783497276652981))
	      (mul-h (ldb (byte 32 32) 1181783497276652981)))
	  #+cmu
	  (multiple-value-bind (hi lo)
	      (bignum::%multiply mul-l new-l)
	    (let ((p (ldb (byte 32 0)
			  (+ (* mul-h new-l)
			     (* mul-l new-h)))))
	      (values (ldb (byte 32 0)
			   (+ hi p))
		      lo
		      state-index))))))))

(defun xor-shift-1024* ()
  (multiple-value-bind (hi lo p)
      (xor-shift-1024*/32 *p* *s*)
    (setf *p* p)
    (+ (ash hi 32)
       lo)))

;;(declaim (ext:end-block))

(defun test-xor-shift-1024* ()
  (init-xor-shift-64 #x1234567887654321)
  (format t "Seed:~%")
  (let ((init-s (make-array 32 :element-type '(unsigned-byte 32))))
    (dotimes (k 16)
      (let ((s (xor-shift-64)))
	(format t "~2d ~d~%" k s) 
	(setf (aref init-s (* 2 k))
	      (ldb (byte 32 0) s))
	(setf (aref init-s (+ 1 (* 2 k)))
	      (ldb (byte 32 32) s))))
    (init-xor-shift-1024* init-s)
    (format t "Outputs:~%")
    (dotimes (k 32)
      (format t "~2d ~D~%" k (xor-shift-1024*)))))

(defun time-xor-shift-1024* (&key (count 10000))
  (init-xor-shift-64 #x1234567887654321)
  (format t "Seed:~%")
  (let ((init-s (make-array 32 :element-type '(unsigned-byte 32))))
    (dotimes (k 16)
      (let ((s (xor-shift-64)))
	(format t "~2d ~d~%" k s) 
	(setf (aref init-s (* 2 k))
	      (ldb (byte 32 0) s))
	(setf (aref init-s (+ 1 (* 2 k)))
	      (ldb (byte 32 32) s))))
    (init-xor-shift-1024* init-s)
    (let ((s 0))
      (declare (type (unsigned-byte 32) s)
	       (optimize (speed 3) (safety 0)))
      (time
       (dotimes (k count)
	 (declare (fixnum k))
	 (setf s (ldb (byte 32 0)
		      (+ s (ldb (byte 32 0) (xor-shift-1024*))))))))
    (let ((s 0))
      (declare (type (unsigned-byte 32) s)
	       (optimize (speed 3) (safety 0)))
      (time
       (dotimes (k count)
	 (declare (fixnum k))
	 (multiple-value-bind (r1 r0 p)
	     (xor-shift-1024*/32 *p* *s*)
	   (setf s (ldb (byte 32 0)
			(+ s r1)))))))
    (let ((s 0)
	  (c2 (* 2 count)))
      (declare (type (unsigned-byte 32) s)
	       (optimize (speed 3) (safety 0)))
      (time
       (dotimes (k c2)
	 (declare (fixnum k))
	 (setf s (ldb (byte 32 0)
		      (+ s (random #x100000000)))))))))
